{"version":3,"file":"index-DPt-h2bd.js","sources":["../../node_modules/three/examples/jsm/geometries/ParametricGeometry.js","../../src/unit7/code.ts"],"sourcesContent":["/**\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\n */\n\nimport {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tVector3\n} from 'three';\n\nclass ParametricGeometry extends BufferGeometry {\n\n\tconstructor( func = ( u, v, target ) => target.set( u, v, Math.cos( u ) * Math.sin( v ) ), slices = 8, stacks = 8 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ParametricGeometry';\n\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tconst EPS = 0.00001;\n\n\t\tconst normal = new Vector3();\n\n\t\tconst p0 = new Vector3(), p1 = new Vector3();\n\t\tconst pu = new Vector3(), pv = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tconst sliceCount = slices + 1;\n\n\t\tfor ( let i = 0; i <= stacks; i ++ ) {\n\n\t\t\tconst v = i / stacks;\n\n\t\t\tfor ( let j = 0; j <= slices; j ++ ) {\n\n\t\t\t\tconst u = j / slices;\n\n\t\t\t\t// vertex\n\n\t\t\t\tfunc( u, v, p0 );\n\t\t\t\tvertices.push( p0.x, p0.y, p0.z );\n\n\t\t\t\t// normal\n\n\t\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\t\tif ( u - EPS >= 0 ) {\n\n\t\t\t\t\tfunc( u - EPS, v, p1 );\n\t\t\t\t\tpu.subVectors( p0, p1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfunc( u + EPS, v, p1 );\n\t\t\t\t\tpu.subVectors( p1, p0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( v - EPS >= 0 ) {\n\n\t\t\t\t\tfunc( u, v - EPS, p1 );\n\t\t\t\t\tpv.subVectors( p0, p1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfunc( u, v + EPS, p1 );\n\t\t\t\t\tpv.subVectors( p1, p0 );\n\n\t\t\t\t}\n\n\t\t\t\t// cross product of tangent vectors returns surface normal\n\n\t\t\t\tnormal.crossVectors( pu, pv ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u, v );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let i = 0; i < stacks; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < slices; j ++ ) {\n\n\t\t\t\tconst a = i * sliceCount + j;\n\t\t\t\tconst b = i * sliceCount + j + 1;\n\t\t\t\tconst c = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\tconst d = ( i + 1 ) * sliceCount + j;\n\n\t\t\t\t// faces one and two\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { ParametricGeometry };\n","import * as THREE from \"three\";\nimport { createBaseScene } from \"../utils/createBaseScene\";\nimport { createTextSprite } from \"../utils/createTextSprite\";\nimport { ParametricGeometry } from \"three/examples/jsm/geometries/ParametricGeometry.js\";\n\n/**\n * // n is used to control maxX, minX, maxY, minY values for the loop\n * Higher values makes the curve larger.\n * Good range is [1, 3]\n */\nlet n = 1;\n/**\n *  // increment value for the loop (within plotFunction).\n * Higher values makes the curve more coarse.\n * Smaller values makes the curve more fine.\n * Good range is [0.01, 1]\n */\nlet incr = 0.01;\n\nconst {\n    camera,\n    render,\n    scene,\n    shouldShowWireframe,\n    sidebar,\n    shouldShowLabels,\n    renderer,\n    directionalLight,\n    canvas,\n    addHelpNote,\n} = createBaseScene({\n    sceneTitle: \"Unit 7: Function Graphing\",\n    cameraZ: n * 15,\n    cameraFov: 90,\n    defaultLightColor: \"#fff\",\n    showAxes: true,\n    showGrid: false,\n    useAmbientLight: true,\n    usePointLight: false,\n    gridHelperSize: n * 10,\n    gridHelperDivisions: n * 10 * 10,\n    showWireframe: false,\n});\n\n// for easy access to the edges of the scene\nconst sceneEdges = {\n    top: canvas.height / 2,\n    bottom: -canvas.height / 2,\n    left: -canvas.width / 2,\n    right: canvas.width / 2,\n};\n\n// this is the signature of the function which will be used to compute the z value\ntype ParsedFn = (x: number, y: number) => number;\n\n/**\n * Takes a string representing the math operation to compute z value\n * and returns a function that can be used to compute the z value.\n * The function string comes from the user input, and will be parsed to a function definition.\n * see `defaultFunctions` for examples of a few predefined functions.\n */\nconst parseFunction = (fn: string): ParsedFn => {\n    return new Function(\"x\", \"y\", `return ${fn}`) as any;\n};\n\n/**\n * Generates a parametric function based on the parsed function.\n * This function will be used to generate the geometry of the curve.\n */\nconst generateParametricFunction = (fn: ParsedFn) => {\n    const parametricFunction = (\n        u: number,\n        v: number,\n        target: THREE.Vector3,\n    ) => {\n        const x = (u - 0.5) * 2 * n; // Map u from [0, 1] to [-n, n]\n        const y = (v - 0.5) * 2 * n; // Map v from [0, 1] to [-n, n]\n        const z = fn(x, y);\n        target.set(x, y, z);\n    };\n    return parametricFunction;\n};\n\n//computes the size of the ground plane, to stay scaled with the curve\nconst groundSize = (n: number) => n * 100;\n\n//computes the number of segments for the curve\nconst getCurveSegments = (n: number, incr: number) =>\n    Math.max(10, Math.floor((2 * n) / incr));\n\n/**\n * Configure the ground plane.\n * - Assemble the geometry and material.\n * - Add the ground to the scene.\n * - Set the position and rotation to be prendicular to the curve.\n */\nconst groundGeometry = new THREE.PlaneGeometry(\n    groundSize(n),\n    groundSize(n),\n    10,\n    10,\n);\nconst groundMaterial = new THREE.MeshStandardMaterial({\n    color: \"#84bbfa\",\n    side: THREE.DoubleSide,\n    wireframe: false,\n    opacity: 0.5,\n});\n\nconst ground = new THREE.Mesh(groundGeometry, groundMaterial);\nground.rotation.x = Math.PI / 2;\nground.position.y = -n * 5;\nscene.add(ground);\n\n/**\n * Setup the curve.\n * - Assemble the geometry and material.\n * - Add the curve to the scene.\n */\nconst curveGeometry = new THREE.BufferGeometry();\nconst curveMaterial = new THREE.MeshStandardMaterial({\n    side: THREE.DoubleSide,\n    flatShading: false, // Smooth surface appearance\n    wireframe: shouldShowWireframe(),\n    vertexColors: true, // Enable vertex colors,\n});\nconst curve = new THREE.Mesh(curveGeometry, curveMaterial);\nscene.add(curve);\n\n/**\n * This where the actual curve is drawn. It edits the geometry of the curve.\n * It accepts a string representing the function to plot, parse it, and use it to compute z values.\n */\nconst plotFunction = (fnString: string) => {\n    const fn = parseFunction(fnString);\n\n    // guard against 0 values as they cause infinite loops\n    if (!n || !incr) {\n        alert(\"Please set N and Increment values.\");\n        return;\n    }\n\n    // setup a new parametric geometry\n    const parametricGeometry = new ParametricGeometry(\n        generateParametricFunction(fn), // Parametric function is generated based on the parsed function\n        getCurveSegments(n, incr),\n        getCurveSegments(n, incr),\n    );\n\n    // Generate vertex colors based on position\n    const positions = parametricGeometry.getAttribute(\"position\").array;\n    const colors: number[] = [];\n\n    /**\n     * For each vertex,\n     * - Push three values into `positions` array representing (x, y, z) coordinates.\n     * - Push three values into `colors` array representing (r, g, b) values based on the (x, y, z) coordinates.\n     */\n    for (let i = 0; i < positions.length; i += 3) {\n        const x = positions[i]!;\n        const y = positions[i + 1]!;\n        const z = positions[i + 2]!;\n\n        // Normalize coordinates to [0, 1] for RGB mapping\n        const r = (x + n) / (2 * n);\n        const g = (y + n) / (2 * n);\n        const b = (z + n) / (2 * n);\n\n        colors.push(r, g, b);\n    }\n\n    // Assign the color attribute to the geometry\n    parametricGeometry.setAttribute(\n        \"color\",\n        new THREE.Float32BufferAttribute(colors, 3), // RGB colors\n    );\n\n    curve.geometry.dispose(); // free up memory of the previous geometry\n    curve.geometry = parametricGeometry; // assign the edited geometry to the curve\n\n    // ensure that the ground plane is scaled with the curve\n    ground.geometry = new THREE.PlaneGeometry(\n        groundSize(n),\n        groundSize(n),\n        10,\n        10,\n    );\n};\n\n/**\n * Handling shadows:\n * - configure necessary objects to cast and receive shadows.\n * - configure the directional light position and other properties.\n * - set the light source at the top right corner of the canvas.\n * - configure the shadow camera properties.\n */\ndirectionalLight.position.set(sceneEdges.right, sceneEdges.top, 0);\ndirectionalLight.intensity = 2;\n\nrenderer.shadowMap.enabled = true;\nrenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\ncurve.castShadow = true;\ncurve.receiveShadow = false;\n\nground.castShadow = false;\nground.receiveShadow = true;\n\n// shadow camera properties\nconst dlCameraFactor = 2000;\ndirectionalLight.castShadow = true;\ndirectionalLight.shadow.camera.near = dlCameraFactor * 0;\ndirectionalLight.shadow.camera.far = dlCameraFactor;\ndirectionalLight.shadow.camera.left = -dlCameraFactor;\ndirectionalLight.shadow.camera.right = dlCameraFactor;\ndirectionalLight.shadow.camera.top = dlCameraFactor;\ndirectionalLight.shadow.camera.bottom = -dlCameraFactor;\n\n/**\n * These are the default functions that the user can choose from.\n * They will be used to power the user input.\n */\nconst defaultFunctions = [\n    {\n        name: \"Hyperbolic Paraboloid\",\n        fn: `x ** 2 - y ** 2`, // Saddle-shaped hyperbolic paraboloid.\n    },\n    {\n        name: \"Parabola\",\n        fn: `x ** 2 + y ** 2`, // A paraboloid (bowl shape).\n    },\n    {\n        name: \"Deep Parabola\",\n        fn: `3 * x ** 2 + 3 * y ** 2`, // A scaled paraboloid.\n    },\n\n    {\n        name: \"Cone\",\n        fn: `Math.sqrt(x ** 2 + y ** 2)`, // A cone with the vertex at (0, 0, 0).\n    },\n] as const;\n\n/**\n * A variable that is used to track if the function has changed.\n * If it is set to true the `plotFunction` is called in the next frame.\n * It is set to true when the user changes the function,\n *    and then set to false after the function is plotted.\n */\nlet functionChanged = true;\nlet fnString = defaultFunctions[0].fn as string;\n\n/**\n * Scene options and necessary listeners and UI elements.\n * - Select Function: Choose from the predefined functions to plot.\n * - Custom Function: Enter a custom function to plot. Use Javascript notation.\n * - N: Set minX, maxX, minY, maxY values for the function.\n * - Incr: Set the increment value for the loop.\n * - Ground Color: Set the color of the ground plane.\n * - Ground Y: Set the Y position of the ground plane.\n */\nconst sceneOptionsDiv = document.createElement(\"div\");\nsceneOptionsDiv.classList.add(\"mb-4\");\n\nsceneOptionsDiv.innerHTML = `\n   <hr class=\"border border-b-[#000] mb-2\" />\n    <h2 class=\"text-xl font-bold text-center mb-2\">Scene Options</h2>\n    <div class=\"flex flex-col space-y-2 text-lg\">\n        <div>\n            <label for=\"selectFunction\" class=\"font-bold\">Select Function: </label>\n                ${defaultFunctions\n                    .map(\n                        (f) =>\n                            `<label class=\"flex flex-col py-1\">\n                                 <div>\n                                    <input type=\"radio\" name=\"selectFunction\" \n                                         class=\"selectFunction\"\n                                         value=\"${f.fn}\" \n                                         ${f.fn === fnString ? \"checked\" : \"\"} \n                                    />\n                                    <span>${f.name}</span> \n                                 </div>\n                                 <div class=\"ml-5\">\n                                    <code class=\"block bg-gray-200 text-blue-600 font-mono text-sm p-2 rounded\">\n                                       z = ${f.fn}\n                                    </code>\n                                 </div>\n                            </label>`,\n                    )\n                    .join(\"\")}\n        </div>\n        <div class=\"flex flex-col space-y-2 text-lg\">\n            <label for=\"function\" class=\"font-bold\">Custom Function:</label>\n            <div class=\"text-sm\">Please follow Javascript notation (and not Math), similar to the options above.</div>\n            <div class=\"flex gap-1 items-center\">\n                <div>z = </div>\n                <input type=\"text\" id=\"customFunction\" class=\"p-2 border border-gray-400 rounded\" />\n            </div>\n            <button id=\"plotFunction\" class=\"p-2 bg-blue-500 text-white rounded\">Plot</button>\n        </div>\n        <div class=\"flex items-center space-x-2\">\n            <span class=\"font-bold\">N:</span>\n            <input type=\"range\" id=\"nInput\" min=\"${0.1}\" max=\"${3}\" step=\"0.1\" value=\"${n}\" />\n        </div>\n        <div class=\"flex items-center space-x-2\">\n            <span class=\"font-bold\">Incr:</span>\n            <input type=\"range\" id=\"incrInput\" min=\"${0.01}\" max=\"${1}\" step=\"0.01\" value=\"${incr}\" />\n        </div>\n        <div class=\"flex flex items-center space-x-2\">\n           <label for=\"groundColor\" class=\"font-bold\">Ground Color:</label>\n            <input type=\"color\" id=\"groundColor\" value=\"#84bbfa\" />\n        </div>\n        <div class=\"flex items-center space-x-2\">\n            <label for=\"groundY\" class=\"font-bold\">Ground Y:</label>\n            <input type=\"range\" id=\"groundY\" min=\"-30\" max=\"0\" step=\"0.1\" value=\"0\" />\n        </div>\n    </div>\n    `;\n\nsidebar.appendChild(sceneOptionsDiv);\n\nconst functionRadios = document.querySelectorAll(\".selectFunction\");\nconst customFunctionInput = document.querySelector(\n    \"#customFunction\",\n) as HTMLInputElement;\nconst plotFunctionButton = document.querySelector(\n    \"#plotFunction\",\n) as HTMLButtonElement;\nconst nInput = document.querySelector(\"#nInput\") as HTMLInputElement;\nconst incrInput = document.querySelector(\"#incrInput\") as HTMLInputElement;\nconst groundColorInput = document.querySelector(\n    \"#groundColor\",\n) as HTMLInputElement;\nconst groundYInput = document.querySelector(\"#groundY\") as HTMLInputElement;\n\ncustomFunctionInput.value = fnString;\nincrInput.value = incr.toString();\nnInput.value = n.toString();\ngroundColorInput.value = \"#\" + groundMaterial.color.getHexString().toString();\ngroundYInput.value = ground.position.y.toString();\n\nfunctionRadios.forEach((radio) => {\n    radio.addEventListener(\"change\", (e) => {\n        const target = e.target as HTMLInputElement;\n        const newFnString = target.value;\n        fnString = newFnString;\n        functionChanged = true;\n        customFunctionInput.value = newFnString;\n    });\n});\n\nplotFunctionButton.addEventListener(\"click\", () => {\n    fnString = customFunctionInput.value;\n    functionChanged = true;\n    // unchecked all radio buttons\n    functionRadios.forEach((r) => {\n        const v = r.getAttribute(\"value\");\n        (r as HTMLInputElement).checked = v === fnString;\n    });\n});\n\nnInput.addEventListener(\"input\", (e) => {\n    setTimeout(() => {\n        n = parseFloat((e.target as HTMLInputElement).value);\n        functionChanged = true;\n    }, 1500);\n});\n\nincrInput.addEventListener(\"input\", (e) => {\n    incr = parseFloat((e.target as HTMLInputElement).value);\n    functionChanged = true;\n});\n\ngroundColorInput.addEventListener(\"input\", (e) => {\n    const color = (e.target as HTMLInputElement).value;\n    groundMaterial.color.set(color);\n});\n\ngroundYInput.addEventListener(\"input\", (e) => {\n    const y = parseFloat((e.target as HTMLInputElement).value);\n    ground.position.y = y;\n});\n\ncamera.position.set(n * 4, n * 4, n * 4);\ncamera.lookAt(0, 0, 0);\n\nconst edge = 3;\n\n/**\n * Add some directional labels to the scene\n * - X, Y, Z labels at the edges of the scene.\n * - Labels for the first few integers on each axis.\n */\n\nconst createAxisLabels = (\n    axis: \"x\" | \"y\" | \"z\",\n): THREE.Sprite<THREE.Object3DEventMap>[] => {\n    const labels: THREE.Sprite<THREE.Object3DEventMap>[] = [];\n    const axisName = createTextSprite(axis.toUpperCase());\n    axisName.position.set(0, 0, 0);\n    axisName.position[axis] = edge + 1;\n    labels.push(axisName);\n\n    for (let i = 0; i <= edge; i++) {\n        const label = createTextSprite(i.toString());\n        label.position.set(0, 0, 0);\n        label.position[axis] = i;\n        labels.push(label);\n    }\n    return labels;\n};\n\nconst labels = [\n    ...createAxisLabels(\"x\"),\n    ...createAxisLabels(\"y\"),\n    ...createAxisLabels(\"z\"),\n];\n\nlabels.forEach((l) => scene.add(l));\n\n/**\n * Animation loop\n * - Animate the scene.\n * - Update the materials and labels based on the user's choice.\n * - If the function has changed, plot the new function, and set the flag to false.\n */\n\nconst animate = () => {\n    if (functionChanged) {\n        plotFunction(fnString);\n        functionChanged = false;\n    }\n    const materials = [\n        // plane.material,\n        curve.material,\n    ];\n    materials.forEach((m) => {\n        m.wireframe = shouldShowWireframe();\n    });\n\n    labels.forEach((l) => {\n        l.visible = shouldShowLabels();\n    });\n\n    requestAnimationFrame(animate);\n    render();\n};\n\nanimate();\n\n// help note: accessed  from the UI through the `Help` button.\naddHelpNote({\n    title: \"Scene Options\",\n    description: \"These options are specified for this scene:\",\n    points: [\n        \"Select Function: Choose from the predefined functions to plot.\",\n        \"Custom Function: Enter a custom function to plot. Use Javascript notation.\",\n        `N: Set minX, maxX, minY, maxY values for the function. Default is ${n}.`,\n        `Incr: Set the increment value for the loop. Default is ${incr}.`,\n        `Ground Color: Set the color of the ground plane. Default is ${groundColorInput.value}.`,\n        `Ground Y: Set the Y position of the ground plane. Default is ${ground.position.y}.`,\n    ],\n});\n"],"names":["ParametricGeometry","BufferGeometry","func","u","v","target","slices","stacks","indices","vertices","normals","uvs","EPS","normal","Vector3","p0","p1","pu","pv","sliceCount","i","j","a","b","c","d","Float32BufferAttribute","source","n","incr","camera","render","scene","shouldShowWireframe","sidebar","shouldShowLabels","renderer","directionalLight","canvas","addHelpNote","createBaseScene","sceneEdges","parseFunction","fn","generateParametricFunction","x","y","z","groundSize","getCurveSegments","groundGeometry","THREE.PlaneGeometry","groundMaterial","THREE.MeshStandardMaterial","THREE.DoubleSide","ground","THREE.Mesh","curveGeometry","THREE.BufferGeometry","curveMaterial","curve","plotFunction","fnString","parametricGeometry","positions","colors","r","g","THREE.Float32BufferAttribute","THREE.PCFSoftShadowMap","dlCameraFactor","defaultFunctions","functionChanged","sceneOptionsDiv","f","functionRadios","customFunctionInput","plotFunctionButton","nInput","incrInput","groundColorInput","groundYInput","radio","e","newFnString","color","edge","createAxisLabels","axis","labels","axisName","createTextSprite","label","l","animate","m"],"mappings":"+JAWA,MAAMA,WAA2BC,CAAe,CAE/C,YAAaC,EAAO,CAAEC,EAAGC,EAAGC,IAAYA,EAAO,IAAKF,EAAGC,EAAG,KAAK,IAAKD,CAAC,EAAK,KAAK,IAAKC,EAAK,EAAEE,EAAS,EAAGC,EAAS,EAAI,CAEnH,MAAO,EAEP,KAAK,KAAO,qBAEZ,KAAK,WAAa,CACjB,KAAML,EACN,OAAQI,EACR,OAAQC,CACR,EAID,MAAMC,EAAU,CAAE,EACZC,EAAW,CAAE,EACbC,EAAU,CAAE,EACZC,EAAM,CAAE,EAERC,EAAM,KAENC,EAAS,IAAIC,EAEbC,EAAK,IAAID,EAAWE,EAAK,IAAIF,EAC7BG,EAAK,IAAIH,EAAWI,EAAK,IAAIJ,EAI7BK,EAAab,EAAS,EAE5B,QAAUc,EAAI,EAAGA,GAAKb,EAAQa,IAAO,CAEpC,MAAMhB,EAAIgB,EAAIb,EAEd,QAAUc,EAAI,EAAGA,GAAKf,EAAQe,IAAO,CAEpC,MAAMlB,EAAIkB,EAAIf,EAIdJ,EAAMC,EAAGC,EAAGW,CAAI,EAChBN,EAAS,KAAMM,EAAG,EAAGA,EAAG,EAAGA,EAAG,CAAG,EAM5BZ,EAAIS,GAAO,GAEfV,EAAMC,EAAIS,EAAKR,EAAGY,CAAI,EACtBC,EAAG,WAAYF,EAAIC,CAAI,IAIvBd,EAAMC,EAAIS,EAAKR,EAAGY,CAAI,EACtBC,EAAG,WAAYD,EAAID,CAAI,GAInBX,EAAIQ,GAAO,GAEfV,EAAMC,EAAGC,EAAIQ,EAAKI,CAAI,EACtBE,EAAG,WAAYH,EAAIC,CAAI,IAIvBd,EAAMC,EAAGC,EAAIQ,EAAKI,CAAI,EACtBE,EAAG,WAAYF,EAAID,CAAI,GAMxBF,EAAO,aAAcI,EAAIC,CAAE,EAAG,UAAW,EACzCR,EAAQ,KAAMG,EAAO,EAAGA,EAAO,EAAGA,EAAO,CAAG,EAI5CF,EAAI,KAAMR,EAAGC,CAAG,CAEpB,CAEA,CAIE,QAAUgB,EAAI,EAAGA,EAAIb,EAAQa,IAE5B,QAAUC,EAAI,EAAGA,EAAIf,EAAQe,IAAO,CAEnC,MAAMC,EAAIF,EAAID,EAAaE,EACrBE,EAAIH,EAAID,EAAaE,EAAI,EACzBG,IAAMJ,EAAI,GAAMD,EAAaE,EAAI,EACjCI,GAAML,EAAI,GAAMD,EAAaE,EAInCb,EAAQ,KAAMc,EAAGC,EAAGE,CAAG,EACvBjB,EAAQ,KAAMe,EAAGC,GAAGC,CAAG,CAE3B,CAME,KAAK,SAAUjB,CAAS,EACxB,KAAK,aAAc,WAAY,IAAIkB,EAAwBjB,EAAU,EAAK,EAC1E,KAAK,aAAc,SAAU,IAAIiB,EAAwBhB,EAAS,EAAK,EACvE,KAAK,aAAc,KAAM,IAAIgB,EAAwBf,EAAK,EAAK,CAEjE,CAEC,KAAMgB,EAAS,CAEd,aAAM,KAAMA,CAAQ,EAEpB,KAAK,WAAa,OAAO,OAAQ,CAAE,EAAEA,EAAO,UAAY,EAEjD,IAET,CAEA,CC9HA,IAAIC,EAAI,EAOJC,EAAO,IAEX,KAAM,CACF,OAAAC,EACA,OAAAC,GACA,MAAAC,EACA,oBAAAC,EACA,QAAAC,GACA,iBAAAC,GACA,SAAAC,EACA,iBAAAC,EACA,OAAAC,EACA,YAAAC,EACJ,EAAIC,GAAgB,CAChB,WAAY,4BACZ,QAASZ,EAAI,GACb,UAAW,GACX,kBAAmB,OACnB,SAAU,GACV,SAAU,GACV,gBAAiB,GACjB,cAAe,GACf,eAAgBA,EAAI,GACpB,oBAAqBA,EAAI,GAAK,GAC9B,cAAe,EACnB,CAAC,EAGKa,EAAa,CACf,IAAKH,EAAO,OAAS,EACrB,OAAQ,CAACA,EAAO,OAAS,EACzB,KAAM,CAACA,EAAO,MAAQ,EACtB,MAAOA,EAAO,MAAQ,CAC1B,EAWMI,GAAiBC,GACZ,IAAI,SAAS,IAAK,IAAK,UAAUA,CAAE,EAAE,EAO1CC,GAA8BD,GACL,CACvBxC,EACAC,EACAC,IACC,CACK,MAAAwC,GAAK1C,EAAI,IAAO,EAAIyB,EACpBkB,GAAK1C,EAAI,IAAO,EAAIwB,EACpBmB,EAAIJ,EAAGE,EAAGC,CAAC,EACVzC,EAAA,IAAIwC,EAAGC,EAAGC,CAAC,CACtB,EAKEC,EAAcpB,GAAcA,EAAI,IAGhCqB,EAAmB,CAACrB,EAAWC,IACjC,KAAK,IAAI,GAAI,KAAK,MAAO,EAAID,EAAKC,CAAI,CAAC,EAQrCqB,GAAiB,IAAIC,EACvBH,EAAWpB,CAAC,EACZoB,EAAWpB,CAAC,EACZ,GACA,EACJ,EACMwB,EAAiB,IAAIC,EAA2B,CAClD,MAAO,UACP,KAAMC,EACN,UAAW,GACX,QAAS,EACb,CAAC,EAEKC,EAAS,IAAIC,EAAWN,GAAgBE,CAAc,EAC5DG,EAAO,SAAS,EAAI,KAAK,GAAK,EAC9BA,EAAO,SAAS,EAAI,CAAC3B,EAAI,EACzBI,EAAM,IAAIuB,CAAM,EAOhB,MAAME,GAAgB,IAAIC,EACpBC,GAAgB,IAAIN,EAA2B,CACjD,KAAMC,EACN,YAAa,GACb,UAAWrB,EAAoB,EAC/B,aAAc,EAClB,CAAC,EACK2B,EAAQ,IAAIJ,EAAWC,GAAeE,EAAa,EACzD3B,EAAM,IAAI4B,CAAK,EAMf,MAAMC,GAAgBC,GAAqB,CACjC,MAAAnB,EAAKD,GAAcoB,CAAQ,EAG7B,GAAA,CAAClC,GAAK,CAACC,EAAM,CACb,MAAM,oCAAoC,EAC1C,MAAA,CAIJ,MAAMkC,EAAqB,IAAI/D,GAC3B4C,GAA2BD,CAAE,EAC7BM,EAAiBrB,EAAGC,CAAI,EACxBoB,EAAiBrB,EAAGC,CAAI,CAC5B,EAGMmC,EAAYD,EAAmB,aAAa,UAAU,EAAE,MACxDE,EAAmB,CAAC,EAO1B,QAAS7C,EAAI,EAAGA,EAAI4C,EAAU,OAAQ5C,GAAK,EAAG,CACpC,MAAAyB,EAAImB,EAAU5C,CAAC,EACf0B,EAAIkB,EAAU5C,EAAI,CAAC,EACnB2B,EAAIiB,EAAU5C,EAAI,CAAC,EAGnB8C,GAAKrB,EAAIjB,IAAM,EAAIA,GACnBuC,GAAKrB,EAAIlB,IAAM,EAAIA,GACnBL,GAAKwB,EAAInB,IAAM,EAAIA,GAElBqC,EAAA,KAAKC,EAAGC,EAAG5C,CAAC,CAAA,CAIJwC,EAAA,aACf,QACA,IAAIK,EAA6BH,EAAQ,CAAC,CAC9C,EAEAL,EAAM,SAAS,QAAQ,EACvBA,EAAM,SAAWG,EAGVR,EAAA,SAAW,IAAIJ,EAClBH,EAAWpB,CAAC,EACZoB,EAAWpB,CAAC,EACZ,GACA,EACJ,CACJ,EASAS,EAAiB,SAAS,IAAII,EAAW,MAAOA,EAAW,IAAK,CAAC,EACjEJ,EAAiB,UAAY,EAE7BD,EAAS,UAAU,QAAU,GAC7BA,EAAS,UAAU,KAAOiC,GAE1BT,EAAM,WAAa,GACnBA,EAAM,cAAgB,GAEtBL,EAAO,WAAa,GACpBA,EAAO,cAAgB,GAGvB,MAAMe,EAAiB,IACvBjC,EAAiB,WAAa,GAC9BA,EAAiB,OAAO,OAAO,KAAOiC,EAAiB,EACvDjC,EAAiB,OAAO,OAAO,IAAMiC,EACrCjC,EAAiB,OAAO,OAAO,KAAO,CAACiC,EACvCjC,EAAiB,OAAO,OAAO,MAAQiC,EACvCjC,EAAiB,OAAO,OAAO,IAAMiC,EACrCjC,EAAiB,OAAO,OAAO,OAAS,CAACiC,EAMzC,MAAMC,EAAmB,CACrB,CACI,KAAM,wBACN,GAAI,iBACR,EACA,CACI,KAAM,WACN,GAAI,iBACR,EACA,CACI,KAAM,gBACN,GAAI,yBACR,EAEA,CACI,KAAM,OACN,GAAI,4BAAA,CAEZ,EAQA,IAAIC,EAAkB,GAClBV,EAAWS,EAAiB,CAAC,EAAE,GAWnC,MAAME,EAAkB,SAAS,cAAc,KAAK,EACpDA,EAAgB,UAAU,IAAI,MAAM,EAEpCA,EAAgB,UAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAMVF,EACG,IACIG,GACG;AAAA;AAAA;AAAA;AAAA,kDAIsBA,EAAE,EAAE;AAAA,2CACXA,EAAE,KAAOZ,EAAW,UAAY,EAAE;AAAA;AAAA,4CAEjCY,EAAE,IAAI;AAAA;AAAA;AAAA;AAAA,6CAILA,EAAE,EAAE;AAAA;AAAA;AAAA,qCAI7B,EACC,KAAK,EAAE,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mDAasB,EAAG,+BAAkC9C,CAAC;AAAA;AAAA;AAAA;AAAA,sDAInC,GAAI,gCAAmCC,CAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAajGK,GAAQ,YAAYuC,CAAe,EAEnC,MAAME,EAAiB,SAAS,iBAAiB,iBAAiB,EAC5DC,EAAsB,SAAS,cACjC,iBACJ,EACMC,GAAqB,SAAS,cAChC,eACJ,EACMC,EAAS,SAAS,cAAc,SAAS,EACzCC,EAAY,SAAS,cAAc,YAAY,EAC/CC,EAAmB,SAAS,cAC9B,cACJ,EACMC,GAAe,SAAS,cAAc,UAAU,EAEtDL,EAAoB,MAAQd,EAC5BiB,EAAU,MAAQlD,EAAK,SAAS,EAChCiD,EAAO,MAAQlD,EAAE,SAAS,EAC1BoD,EAAiB,MAAQ,IAAM5B,EAAe,MAAM,eAAe,SAAS,EAC5E6B,GAAa,MAAQ1B,EAAO,SAAS,EAAE,SAAS,EAEhDoB,EAAe,QAASO,GAAU,CACxBA,EAAA,iBAAiB,SAAWC,GAAM,CAEpC,MAAMC,EADSD,EAAE,OACU,MAChBrB,EAAAsB,EACOZ,EAAA,GAClBI,EAAoB,MAAQQ,CAAA,CAC/B,CACL,CAAC,EAEDP,GAAmB,iBAAiB,QAAS,IAAM,CAC/Cf,EAAWc,EAAoB,MACbJ,EAAA,GAEHG,EAAA,QAAST,GAAM,CACpB,MAAA9D,EAAI8D,EAAE,aAAa,OAAO,EAC/BA,EAAuB,QAAU9D,IAAM0D,CAAA,CAC3C,CACL,CAAC,EAEDgB,EAAO,iBAAiB,QAAU,GAAM,CACpC,WAAW,IAAM,CACTlD,EAAA,WAAY,EAAE,OAA4B,KAAK,EACjC4C,EAAA,IACnB,IAAI,CACX,CAAC,EAEDO,EAAU,iBAAiB,QAAU,GAAM,CAChClD,EAAA,WAAY,EAAE,OAA4B,KAAK,EACpC2C,EAAA,EACtB,CAAC,EAEDQ,EAAiB,iBAAiB,QAAU,GAAM,CACxC,MAAAK,EAAS,EAAE,OAA4B,MAC9BjC,EAAA,MAAM,IAAIiC,CAAK,CAClC,CAAC,EAEDJ,GAAa,iBAAiB,QAAU,GAAM,CAC1C,MAAMnC,EAAI,WAAY,EAAE,OAA4B,KAAK,EACzDS,EAAO,SAAS,EAAIT,CACxB,CAAC,EAEDhB,EAAO,SAAS,IAAIF,EAAI,EAAGA,EAAI,EAAGA,EAAI,CAAC,EACvCE,EAAO,OAAO,EAAG,EAAG,CAAC,EAErB,MAAMwD,EAAO,EAQPC,EACFC,GACyC,CACzC,MAAMC,EAAiD,CAAC,EAClDC,EAAWC,EAAiBH,EAAK,YAAA,CAAa,EACpDE,EAAS,SAAS,IAAI,EAAG,EAAG,CAAC,EACpBA,EAAA,SAASF,CAAI,EAAIF,EAAO,EACjCG,EAAO,KAAKC,CAAQ,EAEpB,QAAStE,EAAI,EAAGA,GAAKkE,EAAMlE,IAAK,CAC5B,MAAMwE,EAAQD,EAAiBvE,EAAE,SAAA,CAAU,EAC3CwE,EAAM,SAAS,IAAI,EAAG,EAAG,CAAC,EACpBA,EAAA,SAASJ,CAAI,EAAIpE,EACvBqE,EAAO,KAAKG,CAAK,CAAA,CAEdH,OAAAA,CACX,EAEMA,GAAS,CACX,GAAGF,EAAiB,GAAG,EACvB,GAAGA,EAAiB,GAAG,EACvB,GAAGA,EAAiB,GAAG,CAC3B,EAEAE,GAAO,QAASI,GAAM7D,EAAM,IAAI6D,CAAC,CAAC,EASlC,MAAMC,GAAU,IAAM,CACdtB,IACAX,GAAaC,CAAQ,EACHU,EAAA,IAEJ,CAEdZ,EAAM,QACV,EACU,QAASmC,GAAM,CACrBA,EAAE,UAAY9D,EAAoB,CAAA,CACrC,EAEMwD,GAAA,QAASI,GAAM,CAClBA,EAAE,QAAU1D,GAAiB,CAAA,CAChC,EAED,sBAAsB2D,EAAO,EACtB/D,GAAA,CACX,EAEA+D,GAAQ,EAGRvD,GAAY,CACR,MAAO,gBACP,YAAa,8CACb,OAAQ,CACJ,iEACA,6EACA,qEAAqEX,CAAC,IACtE,0DAA0DC,CAAI,IAC9D,+DAA+DmD,EAAiB,KAAK,IACrF,gEAAgEzB,EAAO,SAAS,CAAC,GAAA,CAEzF,CAAC","x_google_ignoreList":[0]}