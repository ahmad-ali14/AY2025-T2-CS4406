{"version":3,"file":"index-c3WmJ9K_.js","sources":["../../src/unit3/code.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { createBaseScene } from \"../utils/createBaseScene\";\n\nconst yellowHex = \"#ffffaa\";\n\nconst {\n    scene,\n    render,\n    shouldShowWireframe,\n    canvas,\n    renderer,\n    directionalLight,\n    camera,\n} = createBaseScene({\n    sceneTitle: \"Unit 3: Bouncing Torus Knot\",\n    cameraZ: 1000,\n    showAxes: false,\n    showGrid: false,\n    showLabels: false,\n    showWireframe: false,\n    useOrbitControls: false,\n    useAmbientLight: false,\n    useDirectionalLight: true,\n    usePointLight: false,\n    defaultLightColor: yellowHex,\n});\n\n/**\n * Prepare the scene to have shadows.\n * For details see: https://threejs.org/docs/#api/en/renderers/WebGLRenderer.shadowMap\n */\nrenderer.shadowMap.enabled = true; // enable shadow mapping\nrenderer.shadowMap.type = THREE.PCFSoftShadowMap; // set the type of shadow mapping\n\n/**\n * Prepares the light simulating daylight.\n * see: https://threejs.org/docs/#api/en/lights/DirectionalLight\n */\ndirectionalLight.color = new THREE.Color(yellowHex); // set a yellow color\nconst top = canvas.height / 2;\nconst left = -canvas.width / 2;\ndirectionalLight.position.set(left, top, 1); // set the position of the light to the top left corner\ndirectionalLight.visible = true; // ensure the light is visible\ndirectionalLight.intensity = camera.position.z * 1.5; // enough intensity to be seen from the camera\ndirectionalLight.castShadow = true; // enable shadow casting from this light\ndirectionalLight.lookAt(0, 0, 0); // make the light look at the origin\n\n/**\n * Now, let's create a torus knot.\n * We need to assemble the geometry and material first into a mesh.\n */\n\n// Configuration for the torus knot\n// see: https://threejs.org/docs/#api/en/geometries/TorusKnotGeometry\nconst torusKnotConfig = {\n    radius: 35, // radius of the torus knot\n    tube: 10, // thickness of tube\n    tubularSegments: 100, // number of segments along the tube\n    radialSegments: 16, // number of segments around the tube\n    p: 2, // number of windings around the torus\n    q: 3, // number of windings around the axis of the torus\n};\n\n// setup the geometry of the torus knot based on the configuration\nconst torusKnotGeometry = new THREE.TorusKnotGeometry(\n    torusKnotConfig.radius,\n    torusKnotConfig.tube,\n    torusKnotConfig.tubularSegments,\n    torusKnotConfig.radialSegments,\n    torusKnotConfig.p,\n    torusKnotConfig.q,\n);\n\n// setup the material of the torus knot\nconst torusKnotMaterial = new THREE.MeshBasicMaterial({\n    color: 0xff00ff, // start from a fixed color\n    wireframe: shouldShowWireframe(), // show wireframe if option is enabled\n    // clipShadows: true,\n});\n\n// create the mesh of the torus knot\nconst torusKnot = new THREE.Mesh(torusKnotGeometry, torusKnotMaterial);\ntorusKnot.position.set(0, 0, 0); // start from the origin\ntorusKnot.castShadow = true; // enable shadow casting\ntorusKnot.receiveShadow = false; // disable shadow receiving\nscene.add(torusKnot); // add the torus knot to the scene\n\nlet xDirection = 1; // horizontal direction of the torus knot movement: 1 for right, -1 for left\nlet yDirection = 1; // vertical direction of the torus knot movement: 1 for up, -1 for down\nlet xSpeed = 5; // horizontal speed of the torus knot\nlet ySpeed = 5; // vertical speed of the torus knot\n\nlet rotationSpeed = 0.01; // speed of the rotation of the torus knot\nlet rotationDirection = 1; // direction of the rotation of the torus knot: 1 for clockwise, -1 for counter-clockwise\n\n/**\n * Generates a random color of type THREE.Color.\n */\nconst generateRandomColor = () => {\n    const r = THREE.MathUtils.randInt(0, 255);\n    const g = THREE.MathUtils.randInt(0, 255);\n    const b = THREE.MathUtils.randInt(0, 255);\n    return new THREE.Color(`rgb(${r}, ${g}, ${b})`);\n};\n\n/**\n * We will add a plane to the scene to simulate the ground.\n * This just makes the lights and shadows more visible.\n */\nconst planeGeometry = new THREE.PlaneGeometry(\n    window.innerWidth,\n    window.innerHeight,\n    32,\n    32,\n);\nconst planeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });\nconst plane = new THREE.Mesh(planeGeometry, planeMaterial);\nplane.receiveShadow = true; // enable shadow receiving\nplane.castShadow = false; // disable shadow casting\nplane.position.set(0, 0, 1); // place the plane just above the origin\nscene.add(plane); // add the plane to the scene\n\nconst animate = () => {\n    /**\n     * Let's determine the coordinates of the edges of view first,\n     * then we can compare with the current position of the torus knot\n     */\n    const torusKnotLength = 2 * (torusKnotConfig.radius + torusKnotConfig.tube); // approximation  of the length of the torus knot\n    const viewEdges = {\n        top: -(canvas.height / 2 - torusKnotLength), // screen top x coordinate\n        bottom: canvas.height / 2 - torusKnotLength, // screen bottom x coordinate\n        left: -(canvas.width / 2 - torusKnotLength), // screen left y coordinate\n        right: canvas.width / 2 - torusKnotLength, // screen right y coordinate\n    };\n\n    // find the coordinate of the current position of the torus knot\n    const torusKnotEdgeX = torusKnot.position.x; // x coordinate of the torus knot\n    const torusKnotEdgeY = torusKnot.position.y; // y coordinate of the torus knot\n\n    /**\n     * The edges of the view are the boundaries of x,y coordinates that the torus knot can move.\n     * After hitting an edge, the torus knot will change its direction and color.\n     * E.g. When the x of the torus knot is greater than the right edge of the view, the torus should go left.\n     */\n\n    // check the right edge of the view\n    if (torusKnotEdgeX >= viewEdges.right) {\n        xDirection = -1; // change the direction to left\n        torusKnotMaterial.color = generateRandomColor();\n    }\n\n    // check the left edge of the view\n    if (torusKnotEdgeX <= viewEdges.left) {\n        xDirection = 1; // change the direction to right\n        torusKnotMaterial.color = generateRandomColor();\n    }\n\n    // check the bottom edge of the view\n    if (torusKnotEdgeY >= viewEdges.bottom) {\n        yDirection = -1; // change the direction to up\n        torusKnotMaterial.color = generateRandomColor();\n    }\n\n    // check the top edge of the view\n    if (torusKnotEdgeY <= viewEdges.top) {\n        yDirection = 1; // change the direction to down\n        torusKnotMaterial.color = generateRandomColor();\n    }\n\n    /**\n     * Update the position and rotation of the torus knot.\n     * This is not required it makes things more interesting.\n     */\n    torusKnot.rotation.x += rotationSpeed * rotationDirection;\n    torusKnot.rotation.y += rotationSpeed * rotationDirection;\n    torusKnot.rotation.z += rotationSpeed * rotationDirection;\n\n    /**\n     * Update the position of the torus knot based on the speed and direction.\n     */\n    torusKnot.position.x += xSpeed * xDirection;\n    torusKnot.position.y += ySpeed * yDirection;\n\n    render(); // re-render the scene\n    requestAnimationFrame(animate); // prepare for the next frame\n};\n\nanimate();\n"],"names":["yellowHex","scene","render","shouldShowWireframe","canvas","renderer","directionalLight","camera","createBaseScene","THREE.PCFSoftShadowMap","THREE.Color","top","left","torusKnotConfig","torusKnotGeometry","THREE.TorusKnotGeometry","torusKnotMaterial","THREE.MeshBasicMaterial","torusKnot","THREE.Mesh","xDirection","yDirection","xSpeed","ySpeed","rotationSpeed","rotationDirection","generateRandomColor","r","THREE.MathUtils","g","b","planeGeometry","THREE.PlaneGeometry","planeMaterial","THREE.MeshStandardMaterial","plane","animate","torusKnotLength","viewEdges","torusKnotEdgeX","torusKnotEdgeY"],"mappings":"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"}